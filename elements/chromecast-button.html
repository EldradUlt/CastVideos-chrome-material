<!--
Copyright 2014 Google Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->

<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="../bower_components/core-signals/core-signals.html">
<link rel="import" href="../bower_components/core-tooltip/core-tooltip.html">

<link href='//fonts.googleapis.com/css?family=Roboto:400,100' rel='stylesheet' type='text/css'>

<script type="text/javascript"
        src=""></script>
<!-- Represents the Chromecast button.  It handles both rendering the button and the
connection/actions for Chromecast.

You can change the size using the css selector [element css selector]::shadow svg and setting
height and width.  The cast image is handled by SVG so it'll scale nicely.

The button automatically hides when Chromecast isn't detected.

The button animates during the connection process.

To send play requests use the castManager functions.  This element then receives the events
fired by castManager and based on the sender determines the appropriate action.

When defining the element, appId and castManager are required.  The background color of the element
 can also be set as white or black.  Finally animationInterval can be set to change the animation
 rate of the connection animation.

This element will also sync local state with the chromecast state via castManager method calls.
-->
<polymer-element name="chromecast-button">
  <template>
    <style>
      :host {
        margin-top: 5px;
        display: block;
        overflow: visible;
      }

      .hidden {
        display: none;
      }

      svg {
        width: 34px;
        height: 25px;
        outline: 0;
        border: 0;
      }

      #button_cast:hover {
        cursor: pointer;
        opacity: 0.6;
      }

      .button-black {
        fill: black;
      }

      .button-white {
        fill: white;
      }

      svg.connected {
        fill: #00B9E7;
      }

      core-tooltip.fancy::shadow .core-tooltip {
        opacity: 0;
        -webkit-transition: all 300ms cubic-bezier(0, 1.07, .99, 1.92);
        transition: all 300ms cubic-bezier(0, 1.07, .99, 1.92);
        -webkit-transform: translate3d(0, 10px, 0);
        transform: translate3d(0, 10px, 0);
        font-size: 1.3em;
        font-family: 'Roboto', sans-serif;
        font-weight: 100;
      }

      core-tooltip.fancy:hover::shadow .core-tooltip,
      core-tooltip.fancy:focus::shadow .core-tooltip {
        opacity: 1;
        -webkit-transform: translate3d(0, 0, 0);
        transform: translate3d(0, 0, 0);
      }

      core-tooltip.fancy::shadow .top {
        margin-bottom: 20px;
      }

      core-tooltip.fancy::shadow .core-tooltip.show {
        opacity: 1;
        -webkit-transform: translate3d(0, 0, 0);
        transform: translate3d(0, 0, 0);
      }

    </style>
    <core-tooltip id="tooltip" class="fancy" label="Click to cast videos to your TV" large
                  position="top" noarrow>
      <svg version="1.1" id="button_cast" xmlns="http://www.w3.org/2000/svg"
         xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
         class="{{color == 'white' ? 'button-white' : 'button-black'}}
         {{castManager.isCasting ? 'connected' : ''}}
         {{display ? '': 'hidden'}}"
         viewBox="0 0 51 39" enable-background="new 0 0 51 39" xml:space="preserve">
    <g id="cast_x5F_icon_x5F_on_x5F_light_x5F_mono_1_">
      <path fill-rule="evenodd" clip-rule="evenodd" d="M3,0v16.5c1.4,0.3,2.7,0.7,4,1.2V4h40v28H21.3
        c0.5,1.3,0.9,2.6,1.2,4H51V0H3z" />
      <path visibility="{{castManager.isCasting ? 'visibile' : 'hidden'}}" fill-rule="evenodd"
            clip-rule="evenodd"
            d="M10,7v12.1c4.2,2.3,7.6,5.8,9.9,9.9H44V7H10z"/>
      <path fill="{{connectingCounter == 0 ? '#00B9E7' : ''}}"
            d="M0,33.3V39h5.7C5,36.2,2.8,34,0,33.3z"/>
      <path fill="{{connectingCounter == 1 ? '#00B9E7' : ''}}"
      d="M0,26.1v4C4.5,31,8,34.5,8.8,39h4C12,32.3,6.7,27,0,26.1z"/>
      <path fill="{{connectingCounter == 2 ? '#00B9E7' : ''}}"
      d="M0,19.1v4C8.3,24,15,30.7,15.9,39h4C19,28.4,10.6,20,0,19.1z"/>
    </g>
    </svg>
    </core-tooltip>
    <core-signals on-core-signal-media-action="{{ mediaActionHandler }}"></core-signals>
  </template>
  <script>
    Polymer("chromecast-button", {
      display: false,
      // Autoplay at all times ie. when local video is paused then casted
      autoplay: false,
      // Counter representing which arc to overlay when connecting
      connectingCounter: -1,
      // Interval Id to animate the arc during connection
      intervalId: null,
      // Interval Id to update currentTime on castMedia
      timerId: null,
      // Previous time to update currentTime
      prevTime: null,
      // Time to display the click here to connect message
      tooltipDisplayTime: 2000,
      publish: {
        // AppId of Chromecast receiver
        appId: null,
        // CastManager
        castManager: null,
        // Background color
        color: 'black',
        // Interval for connection animation
        animationInterval: 400
      },
      observe: {
        "castManager.castMedia.playerState": 'castPlayerStateObserver'
      },
      ready: function() {
        if (this.appId !== null
            && window.chrome !== null
            && window.chrome !== undefined
            && window.navigator.vendor === 'Google Inc.') {
          var castScript = document.createElement('script');
          castScript.src = 'https://www.gstatic.com/cv/js/sender/v1/cast_sender.js';
          document.getElementsByTagName('head')[0].appendChild(castScript);

          // Inits cast
          var initializeCastApi = function() {
            if (!chrome.cast || !chrome.cast.isAvailable) {
              setTimeout(initializeCastApi.bind(this), 1000);
            } else {
              var sessionRequest = new chrome.cast.SessionRequest(this.appId);
              var apiConfig = new chrome.cast.ApiConfig(sessionRequest,
                  this.sessionListener.bind(this),
                  this.receiverListener.bind(this));
              chrome.cast.initialize(apiConfig, this.initSuccess.bind(this), this.errorHandler);

              // Add an event listener to try and connect when clicked
              this.$.button_cast.addEventListener('click', function() {
                if (this.castManager.session === chrome.cast.SessionStatus.CONNECTED) {
                  this.stopCasting();
                } else {
                  if (this.intervalId === null) {
                    this.intervalId = window.setInterval(function() {
                      this.connectingCounter = (this.connectingCounter + 1) % 3;
                    }.bind(this), this.animationInterval);
                  }
                  this.castManager.exitFullScreen();
                  this.startCasting();
                }
              }.bind(this));
            }
          };
          initializeCastApi.call(this);
        } else {
          console.log('No receiver app id defined');
        }
      },
      /**
       * Handles when new sessions are connected.
       */
      sessionListener: function(session) {
        console.log('Session listener');
        this.setMediaSession(session);
        // Check if the session has existing media
        if (session.media.length > 0
            && session.media[0].playerState !== chrome.cast.media.PlayerState.IDLE) {
          // If the session has existing media update local info with media details
          this.onMediaDiscovered(session.media[0]);
        }
      },
      /**
       * Handles receiver update events
       */
      receiverListener: function(e) {
        console.log('receiver listener');
        if (e === chrome.cast.ReceiverAvailability.AVAILABLE) {
          // If a receiver is available display the button
          this.display = true;
          this.$.tooltip.show = true;
          window.setTimeout(function() {
            this.$.tooltip.show = false;
          }.bind(this), this.tooltipDisplayTime);
        } else {
          // If no receiver is available, hide the button
          this.display = false;
        }
      },
      initSuccess: function(e) {
        console.log('Chromecast init success');
      },
      /**
       * Start a casting session
       */
      startCasting: function() {
        chrome.cast.requestSession(this.onRequestSessionSuccess.bind(this),
            this.onLaunchError.bind(this));
      },
      /**
       * Stop a casting session
       */
      stopCasting: function() {
        this.castManager.session.stop(this.onStopSuccess.bind(this),
            this.onStopFailure.bind(this));
      },
      /**
       * Loads media onto the Chromecast
       *
       * @param media {cast.Media} media content to load
       */
      loadMedia: function(media, autoplay) {
        this.castManager.showSpinner = true;

        var mediaInfo = new chrome.cast.media.MediaInfo(media.url);
        mediaInfo.metadata = new chrome.cast.media.GenericMediaMetadata();
        mediaInfo.metadata.metadataType = chrome.cast.media.MetadataType.GENERIC;
        mediaInfo.contentType = 'video/mp4';

        mediaInfo.metadata.title = media.title;
        mediaInfo.metadata.subtitle = media.studio;
        mediaInfo.metadata.images = [{'url': media.thumbnailImageUrl}];

        var request = new chrome.cast.media.LoadRequest(mediaInfo);
        request.autoplay = autoplay;

        this.castManager.session.loadMedia(request, this.onMediaDiscovered.bind(this),
            this.onMediaError.bind(this));
      },
      /**
       * Called when a new session has been successfully connected
       *
       * @param session {chrome.cast.Session} Chromecast session
       */
      onRequestSessionSuccess: function(session) {
        console.log('Launch success');
        this.setMediaSession(session);
        this.loadMedia(this.castManager.localMedia, this.autoplay);
      },
      onLaunchError: function(e) {
        console.log('Launch error: ' + JSON.stringify(e));
        this.stopAnimation();
      },
      /**
       * Updates castManager when media is loaded on Chromecast
       *
       * @param media {chrome.cast.media.Media} media loaded on Chromecast
       */
      onMediaDiscovered: function(media) {
        console.log('Media loaded');
        this.castManager.showSpinner = false;

        // Adds a listener for any changes to media
        media.addUpdateListener(this.onCastManagerUpdate.bind(this));
        this.castManager.setCastMedia(media);

        // Sync local media state with the chromecast state
        if (media.playerState === chrome.cast.media.PlayerState.PAUSED) {
          // If media is paused at the beginning
          if (media.currentTime === 0) {
            // If the local media time is not at the beginning and the media matches
            if (this.castManager.localMedia.currentTime !== 0
                && this.castManager.isMediaMatch()
                && this.castManager.hasCastMedia()) {
              // Match time in local media
              this.seek(this.castManager.localMedia.currentTime);
            }
            // If the current local state is play and the user starts casting
            // auto play the content
            if (this.castManager.localMedia.state === cast.Media.STATE.PLAY) {
              this.play();
            }
          } else {
            // If the Chromecast media isn't at the beginning,
            // sync local state with existing video
            this.castManager.seek(media.currentTime, cast.CastManager.SENDER.CHROMECAST);
            this.castManager.pause(cast.CastManager.SENDER.CHROMECAST);
          }
        } else if (media.playerState === chrome.cast.media.PlayerState.PLAYING) {
          // If the current media state is playing send a play event
          this.castManager.seek(media.currentTime, cast.CastManager.SENDER.CHROMECAST);
          this.castManager.play(cast.CastManager.SENDER.CHROMECAST);
        }
      },
      /**
       * Called anytime the media status on Chromecast changes
       */
      onCastManagerUpdate: function(media) {
        console.log('Media changed' + JSON.stringify(this.castManager.castMedia));
      },
      onMediaError: function(e) {
        console.log('Media error: ' + JSON.stringify(e));
      },
      onStopSuccess: function() {
        console.log('Disconnecting succeeded');
      },
      onStopFailure: function(e) {
        console.log('Disconnecting failed: ' + JSON.stringify(e));
      },
      /**
       * Generic on success
       */
      onSuccess: function(e) {
        console.log('Success:' + JSON.stringify(e));
      },
      /**
       * Generic on failure
       */
      onFailure: function(e) {
        console.log('Failure: ' + JSON.stringify(e));
      },
      /**
       * Observes session status and updates the button UI to reflect current session status
       */
      castManagerSessionObserver: function() {
        console.log('Chromecast session content changed');
        // If a session status exists and if session is connected
        if (this.castManager.session.status
            && this.castManager.session.status === chrome.cast.SessionStatus.CONNECTED) {
          // If it is set casting to true and stop the connecting animation
          this.castManager.isCasting = true;
          this.$.tooltip.label = 'Click to disconnect';
          this.stopAnimation();
        } else {
          // Otherwise casting remains false;
          this.castManager.isCasting = false;
          this.$.tooltip.label = 'Click to cast videos to your TV';
        }
      },
      /**
       * Handles core signal events for Chromecast
       */
      mediaActionHandler: function(e, data, sender) {
        // If media is loaded on cast and the action sender isn't chromecast
        switch (data.action) {
          case 'seek':
            if (this.isCastActionable(data)) {
              this.castManager.showSpinner = true;
              this.seek(data.currentTime);
              // Clear the timer so it doesn't update during buffering.
              window.clearInterval(this.timerId);
            }
            break;
          case 'play':
            if (this.isCastActionable(data)) {
              this.showSpinner = true;
              this.play();
            } else if (this.castManager.isCasting && data.sender
                != cast.CastManager.SENDER.CHROMECAST) {
              this.showSpinner = true;
              this.loadMedia(this.castManager.localMedia, true);
            }
            break;
          case 'pause':
            if (this.isCastActionable(data)) {
              this.pause();
            }
            break;
          case 'volume':
            if (this.isCastActionable(data)) {
              this.volume(data.volume);
            }
        }
      },
      /**
       * Helper function that returns true if the request is actionable by cast.
       */
      isCastActionable: function(data) {
        return !!((!this.castManager.hasCastSession()
        && this.castManager.hasCastMedia()
        && (this.castManager.isMediaMatch()
        && data.sender !== cast.CastManager.SENDER.CHROMECAST))
        || data.sender === cast.CastManager.SENDER.CASTCONTROLLER);
      },
      /**
       * Stores the session data in local Media status and starts observing changes to
       * session status.
       */
      setMediaSession: function(session) {
        this.castManager.session = session;
        Object.observe(this.castManager.session, this.castManagerSessionObserver.bind(this));
        this.castManagerSessionObserver();
      },
      /**
       * Stops the connection animation
       */
      stopAnimation: function() {
        window.clearInterval(this.intervalId);
        this.intervalId = null;
        this.connectingCounter = -1;
      },
      /**
       * Local helper function to play the video on cast.
       */
      play: function() {
        this.castManager.castMedia.play(null, this.onSuccess.bind(this), this.onFailure.bind(this));
      },
      /**
       * Local helper function to seek the video on cast.
       *
       * @param time {number} time in seconds to seek to
       */
      seek: function(time) {
        var request = new chrome.cast.media.SeekRequest();
        request.currentTime = Math.round(time);
        this.castManager.castMedia.seek(request,
            this.onSuccess.bind(this), this.onFailure.bind(this));
      },
      /**
       * Local helper function to pause the video on cast.
       */
      pause: function() {
        this.castManager.castMedia.pause(null,
            this.onSuccess.bind(this), this.onFailure.bind(this));
      },
      /**
       * Local helper to change the volume on cast.
       *
       * @param volume {number} 0-1 defining the volume
       */
      volume: function(volume) {
        var vol = new chrome.cast.Volume(volume, false);
        var request = new chrome.cast.media.VolumeRequest(vol);
        this.castManager.castMedia.setVolume(request, this.onSuccess.bind(this),
            this.onFailure.bind(this));
      },
      /**
       * State observer that updates currentTime when casting and stops the spinner when media is
       * playing
       *
       * @param oldVal {chrome.cast.media.PlayerState} previous player state
       * @param newVal {chrome.cast.media.PlayerState} current player state
       */
      castPlayerStateObserver: function(oldVal, newVal) {
        if (this.castManager.isCasting) {
          if (newVal === chrome.cast.media.PlayerState.PLAYING) {
            this.castManager.showSpinner = false;
            // If the media is playing, set an interval to calculate elapsed time
            if (this.timerId === null) {
              this.timerId = window.setInterval(function() {
                var currTime = new Date();
                if (this.prevTime == null) {
                  this.prevTime = new Date();
                }
                var deltaS = (currTime - this.prevTime) / 1000;
                this.castManager.castMedia.currentTime += deltaS;
                this.prevTime = currTime;
              }.bind(this), 1000);
            }
          } else {
            // Otherwise clear the interval and reset previous time
            window.clearInterval(this.timerId);
            this.timerId = null;
            this.prevTime = null;
          }
        }
      }
    });
  </script>
</polymer-element>
