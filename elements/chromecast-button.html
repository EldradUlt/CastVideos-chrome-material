<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="../bower_components/core-signals/core-signals.html">

<script type="text/javascript" src="https://www.gstatic.com/cv/js/sender/v1/cast_sender.js"></script>

<polymer-element name="chromecast-button">
  <template>
    <style>
:host {
  display: block;
}

.hidden {
  display:none;
}

svg {
  width:39px;
  height:30px;
  outline: 0;
  border: 0;
}

#button_cast:hover {
  cursor: pointer;
  opacity:0.6;
}

.button-black {
  fill: black;
}

/*.button-black:hover {*/
  /*fill: #777777;*/
/*}*/

.button-white {
  fill: white;
}

/*.button-white:hover {*/
  /*fill: #aeaeae;*/
/*}*/

svg.connected {
  fill: #00B9E7;
}
    </style>
    <svg version="1.1" id="button_cast" xmlns="http://www.w3.org/2000/svg"
         xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
         class="{{color == 'white' ? 'button-white' : 'button-black'}} {{mediaStatus.isCasting ? 'connected' : ''}} {{display ? '': 'hidden'}}"
	 viewBox="0 0 51 39" enable-background="new 0 0 51 39" xml:space="preserve">
    <g id="cast_x5F_icon_x5F_on_x5F_light_x5F_mono_1_">
      <path fill-rule="evenodd" clip-rule="evenodd" d="M3,0v16.5c1.4,0.3,2.7,0.7,4,1.2V4h40v28H21.3
        c0.5,1.3,0.9,2.6,1.2,4H51V0H3z" />
      <path visibility="{{mediaStatus.isCasting ? 'visibile' : 'hidden'}}" fill-rule="evenodd"
            clip-rule="evenodd"
            d="M10,7v12.1c4.2,2.3,7.6,5.8,9.9,9.9H44V7H10z"/>
      <path fill="{{connectingCounter == 0 ? '#00B9E7' : ''}}"
            d="M0,33.3V39h5.7C5,36.2,2.8,34,0,33.3z"/>
      <path fill="{{connectingCounter == 1 ? '#00B9E7' : ''}}"
      d="M0,26.1v4C4.5,31,8,34.5,8.8,39h4C12,32.3,6.7,27,0,26.1z"/>
      <path fill="{{connectingCounter == 2 ? '#00B9E7' : ''}}"
      d="M0,19.1v4C8.3,24,15,30.7,15.9,39h4C19,28.4,10.6,20,0,19.1z"/>
    </g>
    </svg>
    <core-signals on-core-signal-media-action="{{ mediaActionHandler }}"></core-signals>
  </template>
  <script>
    Polymer("chromecast-button", {
      display: false,
      autoplay: false,
      connectingCounter: -1,
      intervalId: null,
      publish: {
        appId: null,
        mediaStatus: null,
        color: 'black',
        animationInterval: 400
      },
      observe: {
        'mediaStatus.state': 'mediaStatusStateObserver'
      },
      ready: function(){
        if (this.appId != null) {
          //Inits cast
          var initializeCastApi = function () {
            if (!chrome.cast || !chrome.cast.isAvailable) {
              setTimeout(initializeCastApi.bind(this), 1000);
            } else {
              var sessionRequest = new chrome.cast.SessionRequest(this.appId);
              var apiConfig = new chrome.cast.ApiConfig(sessionRequest,
                  this.sessionListener.bind(this),
                  this.receiverListener.bind(this));
              chrome.cast.initialize(apiConfig, this.initSuccess.bind(this), this.errorHandler);

              //Add an event listener to try and connect when clicked
              this.$.button_cast.addEventListener("click", function() {
                if (this.mediaStatus.session == chrome.cast.SessionStatus.CONNECTED) {
                  this.stopCasting.bind(this)();
                } else {
                  if (this.intervalId == null) {
                    this.intervalId = window.setInterval(function () {
                      this.connectingCounter = (this.connectingCounter + 1) % 3;
                    }.bind(this), this.animationInterval);
                  }
                  this.startCasting.bind(this)();
                }
              }.bind(this));
            }
          }.bind(this);
          initializeCastApi();
        } else {
          throw "No receiver app id defined"
        }
      },
      /**
       * Handles when new sessions are connected.
       */
      sessionListener: function (session) {
        console.log("Session listener");
        this.setMediaSession(session);
        //Check if the session has existing media
        if(session.media.length > 0 && session.media[0].playerState != chrome.cast.media.PlayerState.IDLE ) {
          //If the session has existing media update local info with media details
          this.onMediaDiscovered(session.media[0]);
        }
      },
      /**
       * Handles receiver update events
       */
      receiverListener: function (e) {
        console.log('receiver listener');
        if( e === chrome.cast.ReceiverAvailability.AVAILABLE) {
          //If a receiver is available display the button
          this.display = true;
        } else {
          //If no receiver is available, hide the button
          this.display = false;
        }
      },
      initSuccess: function (e) {
        console.log("Chromecast init success");
      },
      startCasting: function () {
        chrome.cast.requestSession(this.onRequestSessionSuccess.bind(this),
            this.onLaunchError.bind(this));
      },
      stopCasting: function () {
        this.mediaStatus.session.stop(this.onStopSuccess.bind(this),
            this.onStopFailure.bind(this));
      },
      /**
       * Loads media onto the Chromecast
       *
       * @param media {cast.Media}
       */
      loadMedia: function (media) {
        var mediaInfo = new chrome.cast.media.MediaInfo(media.url);
        mediaInfo.metadata = new chrome.cast.media.GenericMediaMetadata();
        mediaInfo.metadata.metadataType = chrome.cast.media.MetadataType.GENERIC;
        mediaInfo.contentType = 'video/mp4';

        mediaInfo.metadata.title = media.title;
        mediaInfo.metadata.subtitle = media.creator;
        mediaInfo.metadata.images = [{'url': media.thumbnailImageUrl}];

        var request = new chrome.cast.media.LoadRequest(mediaInfo);
        request.autoplay = this.autoplay;

        this.mediaStatus.session.loadMedia(request, this.onMediaDiscovered.bind(this),
            this.onMediaError.bind(this));
      },
      /**
       * Called when a new session has been successfully connected
       *
       * @param session
       */
      onRequestSessionSuccess: function (session) {
        console.log('Launch success');
        this.setMediaSession(session);
        this.loadMedia(this.mediaStatus.localMedia);
      },
      onLaunchError: function(e) {
        console.log('Launch error: ' + JSON.stringify(e));
        this.stopAnimation();
      },
      /**
       * Updates mediastatus when media is loaded on Chromecast
       *
       * @param media
       */
      onMediaDiscovered: function(media) {
        console.log('Media loaded');

        //Adds an listener for any changes to media
        media.addUpdateListener(this.onMediaStatusUpdate.bind(this));
        this.mediaStatus.setCastMedia(media);

        //Sync local media state with the chromecast state
        if (media.playerState == chrome.cast.media.PlayerState.PAUSED) {
          //If media is paused at the beginning
          if (media.currentTime == 0) {
            //If the local media time is not at the beginning and the media matches
            if (this.mediaStatus.localMedia.currentTime != 0
                && this.mediaStatus.isMediaMatch()) {
              //Match time in local media
              this.seek(this.mediaStatus.localMedia.currentTime);
            } else {
              //If the localMedia time hasn't started yet, auto play both cast and local
              this.mediaStatus.play(cast.MediaStatus.SENDER.CHROMECAST);
              this.play();
            }
            //If the current local state is play and the user starts casting
            //auto play the content
            if (this.mediaStatus.localMedia.state === cast.Media.STATE.PLAY) {
              this.play();
            }
          } else {
            //If the Chromecast media isn't at the beginning,
            //sync local state with existing video
            this.mediaStatus.seek(media.currentTime, cast.MediaStatus.SENDER.CHROMECAST);
            this.mediaStatus.pause(cast.MediaStatus.SENDER.CHROMECAST);
          }
        } else if(media.playerState == chrome.cast.media.PlayerState.PLAYING) {
          //If the current media state is playing send a play event
          this.mediaStatus.seek(media.currentTime, cast.MediaStatus.SENDER.CHROMECAST);
          this.mediaStatus.play(cast.MediaStatus.SENDER.CHROMECAST);
        }
      },
      /**
       * Called anytime the media status on Chromecast changes
       */
      onMediaStatusUpdate: function (media) {
        console.log('Media changed' + JSON.stringify(this.mediaStatus.castMedia));
      },
      onMediaError: function(e) {
        console.log('Media error: ' + JSON.stringify(e));
      },
      onStopSuccess: function() {
        console.log('Disconnecting succeeded');
      },
      onStopFailure: function(e) {
        console.log('Disconnecting failed: ' + JSON.stringify(e));
      },
      /**
       * Generic on success
       */
      onSuccess: function (e) {
        console.log(JSON.stringify(e));
      },
      /**
       * Generic on failure
       */
      onFailure: function (e) {
        console.log(JSON.stringify(e));
      },
      /**
       * Observes session status and updates the button UI to reflect current session status
       */
      mediaStatusSessionObserver: function() {
        console.log("Chromecast session content changed");
        //If a session status exists and if session is connected
        if (this.mediaStatus.session.status
            && this.mediaStatus.session.status == chrome.cast.SessionStatus.CONNECTED) {
          //If it is set casting to true and stop the connecting animation
          this.mediaStatus.isCasting = true;
          this.stopAnimation();
        } else {
          //Otherwise casting remains false;
          this.mediaStatus.isCasting = false;
        }
      },
      /**
       * Handles events for Chromecast
       *
       */
      mediaActionHandler: function (e, data, sender) {
        //If media is loaded on cast and the action sender isn't chromecast
        //TODO(pying): disregard content from local sender when queue displays
        if (this.mediaStatus.hasCastMedia()
            && ((this.mediaStatus.isMediaMatch()
              && data.sender != cast.MediaStatus.SENDER.CHROMECAST)
            || (!this.mediaStatus.isMediaMatch()
              && data.sender === cast.MediaStatus.SENDER.CASTCONTROLLER))) {
            switch (data.action) {
              case 'seek':
                this.seek(data.currentTime);
                break;
              case 'play':
                this.play();
                break;
              case 'pause':
                this.pause();
                break;
            }
        }
        switch (data.action) {
          case 'addToQueue':
            if (this.mediaStatus.hasCastMedia()) {
              this.addToQueue(data.media);
            } else {
              this.loadMedia(data.media);
            }
            break;
          case 'removeFromQueue':
            this.removeFromQueue(data.itemId);
            break;
          case 'queueMoveItem':
            this.queueMoveItem(data.itemId, data.newIndex);
            break;
          case 'queuePlayItem':
            this.queuePlayItem(data.itemId);
            break;
        }
      },
      /**
       * Stores the session data in local Media status and starts observing changes to
       * session status.
       */
      setMediaSession: function(session) {
        this.mediaStatus.session = session;
        Object.observe(this.mediaStatus.session, this.mediaStatusSessionObserver.bind(this));
        this.mediaStatusSessionObserver();
      },
      /**
       * Stops the connection animation
       */
      stopAnimation: function () {
        window.clearInterval(this.intervalId);
        this.intervalId = null;
        this.connectingCounter = -1;
      },
      //Todo(pying): capture if the content in session is not loaded
      /**
       * Local helper function to play the video on cast.
       */
      play: function() {
        this.mediaStatus.castMedia.play(null, this.onSuccess.bind(this), this.onFailure.bind(this));
      },
      /**
       * Local helper function to seek the video on cast.
       *
       * @param time {number} time in seconds to seek to
       */
      seek: function(time){
        var request = new chrome.cast.media.SeekRequest();
        request.currentTime = Math.round(time);
        this.mediaStatus.castMedia.seek(request, this.onSuccess.bind(this), this.onFailure.bind(this));
      },
      /**
       * Local helper function to pause the video on cast
       */
      pause: function() {
        this.mediaStatus.castMedia.pause(null, this.onSuccess.bind(this), this.onFailure.bind(this));
      },
      /**
       * Helper function to add a media item to queue
       *
       * @param media
       */
      addToQueue: function(media) {
        var mediaInfo = new chrome.cast.media.MediaInfo(media.url);

        mediaInfo.metadata = new chrome.cast.media.GenericMediaMetadata();
        mediaInfo.metadata.metadataType = chrome.cast.media.MetadataType.GENERIC;
        mediaInfo.contentType = 'video/mp4';

        mediaInfo.metadata.title = media.title;
        mediaInfo.metadata.subtitle = media.creator;
        mediaInfo.metadata.images = [{'url': media.thumbnailImageUrl}];

        var queueItem = new chrome.cast.media.QueueItem(mediaInfo);

        var request = new chrome.cast.media.QueueInsertRequest([queueItem]);

        this.mediaStatus.castMedia.queueInsert(request, this.onSuccess.bind(this),
            this.onFailure.bind(this));
      },
      removeFromQueue: function(itemId) {
        var removeRequest = new chrome.cast.media.QueueRemoveRequest([itemId]);
        this.mediaStatus.castMedia.queueRemove(removeRequest, this.onSuccess.bind(this), this.onFailure.bind(this));
      },
      queueMoveItem: function(itemId, newIndex) {
        this.mediaStatus.castMedia.queueMoveItemToNewIndex(itemId, newIndex, this.onSuccess.bind(this), this.onFailure.bind(this));
      },
      queuePlayItem: function(itemId) {
        this.mediaStatus.castMedia.queueJumpToItem(itemId, this.onSuccess.bind(this), this.onFailure.bind(this));
      }
    });
  </script>
</polymer-element>
